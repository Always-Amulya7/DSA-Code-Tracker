{
  "metadata": {
    "totalProblems": 3,
    "lastUpdated": "2025-08-27T11:59:12.996Z",
    "breakdown": {
      "Codechef": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 3,
        "Easy": 1,
        "Medium": 1,
        "Hard": 1
      },
      "Hackerrank": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "leetcode-easy-maximum-area-of-longest-diagonal-rectangle",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Maximum Area of Longest Diagonal Rectangle",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int areaOfMaxDiagonal(int[][] dimensions) {\n        int n = dimensions.length;\n        int maxArea = 0, maxDiag = 0;\n\n        for (int i = 0; i < n; i++) {\n            int l = dimensions[i][0];\n            int w = dimensions[i][1];\n            int currDiag = l * l + w * w;\n\n            if (currDiag > maxDiag || (currDiag == maxDiag && l * w > maxArea)) {\n                maxDiag = currDiag;\n                maxArea = l * w;\n            }\n        }\n        return maxArea;\n    }\n}",
        "readme": "3000. Maximum Area of Longest Diagonal RectangleEasyTopicsCompaniesHintYou are given a 2D 0-indexed integer array dimensions.\n\nFor all indices i, 0 <= i < dimensions.length, dimensions[i][0] represents the length and dimensions[i][1] represents the width of the rectangle i.\n\nReturn the area of the rectangle having the longest diagonal. If there are multiple rectangles with the longest diagonal, return the area of the rectangle having the maximum area.\n\nÂ \nExample 1:\n\nInput: dimensions = [[9,3],[8,6]]\nOutput: 48\nExplanation: \nFor index = 0, length = 9 and width = 3. Diagonal length = sqrt(9 * 9 + 3 * 3) = sqrt(90) â‰ˆ 9.487.\nFor index = 1, length = 8 and width = 6. Diagonal length = sqrt(8 * 8 + 6 * 6) = sqrt(100) = 10.\nSo, the rectangle at index 1 has a greater diagonal length therefore we return area = 8 * 6 = 48.\n\n\nExample 2:\n\nInput: dimensions = [[3,4],[4,3]]\nOutput: 12\nExplanation: Length of diagonal is the same for both which is 5, so maximum area = 12.\n\n\nÂ \nConstraints:\n\n\n\t1 <= dimensions.length <= 100\n\tdimensions[i].length == 2\n\t1 <= dimensions[i][0], dimensions[i][1] <= 100\n\nÂ Seen this question in a real interview before?1/5YesNoAccepted166,224/363.6KAcceptance Rate45.7%TopicsArrayWeekly Contest 379CompaniesHint 1Diagonal of rectangle is sqrt(length2 + width2).Discussion (129)Choose a typeCommentðŸ’¡ Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestJedmengAug 26, 2025This is my 1000th POTD ðŸ˜\nÂ Read more29116DamonJul 10, 2025Optimisation tip:\nDon't need to calculate the root\nsqrt(x^2+y^2) can just become x^2 + y^2\nsqrt is quite demanding for performance, so this can be a good optimisationÂ Read moreTip11910NerverAug 26, 2025Acceptance rate is low because people (including myself) can't read ðŸ¤¡Â Read more1145SmarikaJan 11, 2024Try this test case b4 submitting\nGood day :))\ndimensions =\n[[4,7],[8,9],[5,3],[6,10],[2,9],[3,10],[2,2],[5,8],[5,10],[5,6],[8,9],[10,7],[8,9],[3,7],[2,6],[5,1],[7,4],[1,10],[1,7],[6,9],[3,3],[4,6],[8,2],[10,6],[7,9],[9,2],[1,2],[3,8],[10,2],[4,1],[9,7],[10,3],[6,9],[9,8],[7,7],[5,7],[5,4],[6,5],[1,8],[2,3],[7,10],[3,9],[5,7],[2,4],[5,6],[9,5],[8,8],[8,10],[6,8],[5,1],[10,8],[7,4],[2,1],[2,7],[10,3],[2,5],[7,6],[10,5],[10,9],[5,7],[10,6],[4,3],[10,4],[1,5],[8,9],[3,1],[2,5],[9,10],[6,6],[5,10],[10,2],[6,10],[1,1],[8,6],[1,7],[6,3],[9,3],[1,4],[1,1],[10,4],[7,9],[4,5],[2,8],[7,9],[7,3],[4,9],[2,8],[4,6],[9,1],[8,4],[2,4],[7,8],[3,5],[7,6],[8,6],[4,7],[25,60],[39,52],[16,63],[33,56]]Â Read more393Sam_ORAug 26, 20252012 type interview question:Â Read moreFeedback361Shivam KumarSep 13, 2024I can't understand why has this problem such a low acceptance rate !? It isn't even a lil bit tough..!Â Read more246Anish SachdevaJul 07, 2024The problem description needs to be fixed !! it says:\nIf there are multiple rectangles with the longest diagonal, return the area of the rectangle having the maximum area.\ni would assume having the maximum area means maximum among all rectangles, but apparently this means maximum among rectangles with same max diagonal length. This is hyper slippery ground !!! and needs to be fixed asap. Cost me a good 30 mins.Â Read more557Hritam ChowdhuryJan 07, 2024one test case is failing\n[[4,7],[8,9],[5,3],[6,10],[2,9],[3,10],[2,2],[5,8],[5,10],[5,6],[8,9],[10,7],[8,9],[3,7],[2,6],[5,1],[7,4],[1,10],[1,7],[6,9],[3,3],[4,6],[8,2],[10,6],[7,9],[9,2],[1,2],[3,8],[10,2],[4,1],[9,7],[10,3],[6,9],[9,8],[7,7],[5,7],[5,4],[6,5],[1,8],[2,3],[7,10],[3,9],[5,7],[2,4],[5,6],[9,5],[8,8],[8,10],[6,8],[5,1],[10,8],[7,4],[2,1],[2,7],[10,3],[2,5],[7,6],[10,5],[10,9],[5,7],[10,6],[4,3],[10,4],[1,5],[8,9],[3,1],[2,5],[9,10],[6,6],[5,10],[10,2],[6,10],[1,1],[8,6],[1,7],[6,3],[9,3],[1,4],[1,1],[10,4],[7,9],[4,5],[2,8],[7,9],[7,3],[4,9],[2,8],[4,6],[9,1],[8,4],[2,4],[7,8],[3,5],[7,6],[8,6],[4,7],[25,60],[39,52],[16,63],[33,56]]\nwhat is the problem in the solution:\nclass Solution {\npublic:\nint areaOfMaxDiagonal(vector<vector>& dimensions) {\n    int maxArea=0;\n    double maxD = 0;\n    int n = dimensions.size();\n    int l,b;\n    double d;\n    \n    for(int i=0;i<n;i++) {\n        \n         l = dimensions[i][0];\n         b = dimensions[i][1];\n         d = sqrt(l*l + b*b);\n        // cout<<d<<\",\";\n        if(d>=maxD) {\n            maxArea = l*b;\n            maxD=d;\n        } \n    }\n    \n    return maxArea;\n    \n}\n};Â Read more175Yuyi_HaoJan 09, 2024good question to test conditional logicÂ Read more151Azhar Uddin SheikhJan 09, 2024some test cases\n[[4,10],[4,9],[9,3],[10,8]]\n[[2,6],[5,1],[3,10],[8,4]]\n[[25,60], [39,52], [33,56], [16,63]]\n[[6,5],[8,6],[2,10],[8,1],[9,2],[3,5],[3,5]]Â Read more14123413Copyright Â© 2025 LeetCode. All rights reserved.",
        "notes": "Maximum Area of Longest Diagonal Rectangle\n\n          - Summary: The code uses a 2D integer array to represent the dimensions of rectangles. It iterates through each rectangle, calculating the square of its diagonal using the Pythagorean theorem.  It then updates the maximum diagonal and corresponding area if a larger diagonal is found or if the diagonals are equal but the area is larger. Finally, it returns the maximum area found.\n\n          - Time Complexity: O(n), where n is the number of rectangles. This is because the code iterates through the input array once.\n          - Space Complexity: O(1). The algorithm uses a constant amount of extra space to store variables like maxArea and maxDiag, regardless of the input size."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-27T11:59:12.991Z"
    },
    {
      "id": "leetcode-medium-longest-palindromic-substring",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Longest Palindromic Substring",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() == 0) {\n            return \"\";\n        }\n\n        int start = 0;\n        int end = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            int odd = expandAroundCenter(s, i, i);\n            int even = expandAroundCenter(s, i, i + 1);\n            int max_len = Math.max(odd, even);\n\n            if (max_len > end - start) {\n                start = i - (max_len - 1) / 2;\n                end = i + max_len / 2;\n            }\n        }\n\n        return s.substring(start, end + 1);        \n    }\n\n    private int expandAroundCenter(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }    \n}",
        "readme": "5. Longest Palindromic SubstringSolvedMediumTopicsCompaniesHintGiven a string s, return the longest palindromic substring in s.\n\nÂ \nExample 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\n\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n\nÂ \nConstraints:\n\n\n\t1 <= s.length <= 1000\n\ts consist of only digits and English letters.\n\nÂ Seen this question in a real interview before?1/5YesNoAccepted4,094,396/11.3MAcceptance Rate36.3%TopicsTwo PointersStringDynamic ProgrammingCompaniesHint 1How can we reuse a previously computed palindrome to compute a larger palindrome?Hint 2If â€œabaâ€ is a palindrome, is â€œxabaxâ€ a palindrome? Similarly is â€œxabayâ€ a palindrome?Hint 3Complexity based hint:\nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation.Similar QuestionsShortest PalindromeHardPalindrome PermutationEasyPalindrome PairsHardLongest Palindromic SubsequenceMediumPalindromic SubstringsMediumMaximum Number of Non-overlapping Palindrome SubstringsHardDiscussion (496)Choose a typeCommentðŸ’¡ Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestZenMasterVNov 05, 2022Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills\n\" Please don't post any solutions in this discussion tab\"\nIt's almost the rule to find the exact opposite for the discussion of every question. I don't want to see your damned solution!Â Read more1.3K13Akhil ChauhanOct 27, 2023More like longest palindromic nightmareÂ Read more2191SwetNov 04, 2022It took me an hour to solve this even though it's not that difficult but anyhow came to the conclusion that I need to do more practice.Â Read more1273sanemdeepakJan 16, 2019For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?Â Read more17720Neetika BansalJun 04, 2014From the leetcode blog, one of the methods of solving this is:\nA common mistake:\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\nReverse S and become Sâ€™. Find the longest common substring between S and Sâ€™, which must also be the longest palindromic substring.\nThis seemed to work, letâ€™s see some examples below.\nFor example,\nS = â€œcabaâ€, Sâ€™ = â€œabacâ€.\nThe longest common substring between S and Sâ€™ is â€œabaâ€, which is the answer.\nLetâ€™s try another example:\nS = â€œabacdfgdcabaâ€, Sâ€™ = â€œabacdgfdcabaâ€.\nThe longest common substring between S and Sâ€™ is â€œabacdâ€. Clearly, this is not a valid palindrome.\nWe could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substringâ€™s indices are the same as the reversed substringâ€™s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.\nIs this part correct?\nexample string: abcxycba\nreverse string:  abcxycba\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?Â Read more949napoleonNov 08, 2013My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?Â Read more10313Tomas SandvenApr 25, 2023I'm getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\ns =\nDid I break it?Â Read moreFeedback47884danieNov 14, 2016I submitted my solution, and received a Time Limit Exceeded on this test case:\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\n\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug?\nÂ Read more4410miklerAug 25, 2017So I think I finally understood logic of test creators.\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG.\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\nif s == s[::-1]: return sÂ Read more254AlgoEngineJun 17, 2023Visualization of \"Expand from Centers\" solution:\nÂ Read more231123450Copyright Â© 2025 LeetCode. All rights reserved.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-27T11:59:12.992Z"
    },
    {
      "id": "leetcode-hard-length-of-longest-v-shaped-diagonal-segment",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Length of Longest V-Shaped Diagonal Segment",
      "language": "java",
      "files": {
        "code": "/**\nTime Complexity: O(mn)\nSpace Complexity: O(mn)\n */\nclass Solution {\n    private static final int[][] DIRS = { { 1, 1 }, { 1, -1 }, { -1, -1 }, { -1, 1 } };\n\n    public int lenOfVDiagonal(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        // Too many dimensions affect efficiency, so compress k and canTurn into one int\n        int[][][] memo = new int[m][n][1 << 3];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] != 1) {\n                    continue;\n                }\n                int[] maxs = { m - i, j + 1, i + 1, n - j }; //Theoretical maximum (go to the boundary)\n                for (int k = 0; k < 4; k++) { // Enumerate starting direction\n                    // Optimization 1: If the theoretical maximum does not exceed ans, skip recursion\n                    if (maxs[k] > ans) { \n                        ans = Math.max(ans, dfs(i, j, k, 1, 2, grid, memo) + 1);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n\n    private int dfs(int i, int j, int k, int canTurn, int target, int[][] grid, int[][][] memo) {\n        i += DIRS[k][0];\n        j += DIRS[k][1];\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] != target) {\n            return 0;\n        }\n        int mask = k << 1 | canTurn;\n        if (memo[i][j][mask] > 0) {\n            return memo[i][j][mask];\n        }\n        int res = dfs(i, j, k, canTurn, 2 - target, grid, memo);\n        if (canTurn == 1) {\n            int[] maxs = { grid.length - i - 1, j, i, grid[i].length - j - 1 }; // Theoretical maximum (go to the boundary)\n            k = (k + 1) % 4;\n            // Optimization 2: If the theoretical maximum does not exceed res, skip recursion\n            if (maxs[k] > res) {\n                res = Math.max(res, dfs(i, j, k, 0, 2 - target, grid, memo));\n            }\n        }\n        return memo[i][j][mask] = res + 1;\n    }\n}",
        "readme": "3459. Length of Longest V-Shaped Diagonal SegmentSolvedHardTopicsCompaniesHintYou are given a 2D integer matrix grid of size n x m, where each element is either 0, 1, or 2.\n\nA V-shaped diagonal segment is defined as:\n\n\n\tThe segment starts with 1.\n\tThe subsequent elements follow this infinite sequence: 2, 0, 2, 0, ....\n\tThe segment:\n\t\n\t\tStarts along a diagonal direction (top-left to bottom-right, bottom-right to top-left, top-right to bottom-left, or bottom-left to top-right).\n\t\tContinues the sequence in the same diagonal direction.\n\t\tMakes at most one clockwise 90-degree turn to another diagonal direction while maintaining the sequence.\n\t\n\t\n\n\n\n\nReturn the length of the longest V-shaped diagonal segment. If no valid segment exists, return 0.\n\nÂ \nExample 1:\n\n\nInput: grid = [[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]\n\nOutput: 5\n\nExplanation:\n\n\n\nThe longest V-shaped diagonal segment has a length of 5 and follows these coordinates: (0,2) â†’ (1,3) â†’ (2,4), takes a 90-degree clockwise turn at (2,4), and continues as (3,3) â†’ (4,2).\n\n\nExample 2:\n\n\nInput: grid = [[2,2,2,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]\n\nOutput: 4\n\nExplanation:\n\n\n\nThe longest V-shaped diagonal segment has a length of 4 and follows these coordinates: (2,3) â†’ (3,2), takes a 90-degree clockwise turn at (3,2), and continues as (2,1) â†’ (1,0).\n\n\nExample 3:\n\n\nInput: grid = [[1,2,2,2,2],[2,2,2,2,0],[2,0,0,0,0],[0,0,2,2,2],[2,0,0,2,0]]\n\nOutput: 5\n\nExplanation:\n\n\n\nThe longest V-shaped diagonal segment has a length of 5 and follows these coordinates: (0,0) â†’ (1,1) â†’ (2,2) â†’ (3,3) â†’ (4,4).\n\n\nExample 4:\n\n\nInput: grid = [[1]]\n\nOutput: 1\n\nExplanation:\n\nThe longest V-shaped diagonal segment has a length of 1 and follows these coordinates: (0,0).\n\n\nÂ \nConstraints:\n\n\n\tn == grid.length\n\tm == grid[i].length\n\t1 <= n, m <= 500\n\tgrid[i][j] is either 0, 1 or 2.\n\nÂ Seen this question in a real interview before?1/5YesNoAccepted27,365/53.5KAcceptance Rate51.2%TopicsArrayDynamic ProgrammingMemoizationMatrixWeekly Contest 437CompaniesHint 1Use dynamic programming to determine the best point to make a 90-degree rotation in the diagonal path while maintaining the required sequence.Hint 2Represent dynamic programming states as (row, col, currentDirection, hasMadeTurnYet). Track the current position, direction of traversal, and whether a turn has already been made, and take transitions accordingly to find the longest V-shaped diagonal segment.Discussion (138)Choose a typeCommentðŸ’¡ Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestGaurav KumarJun 09, 2025Kanye would love the first picture :)Â Read more175Amr Samy10 hours agoMy 3-day streak ends here.Â Read more1469Aradhya Verma10 hours agoI think i should work at Burger kingÂ Read more905parthasarathireddy10 hours agoToday is Vinayaka Chaturthi. LeetCode decided not to let us celebrate by giving a hard problem. Anyway, wishing you all a Happy Vinayaka Chavithi!Â Read more2248amcodes2k2Feb 16, 2025Can someone explain to me how the answer to the testcase [[1,1,1,2,0,0],[0,0,0,0,1,2]] is 2? Shouldn't it be 3 [(1, 4) -> (0, 3) -> (1,2)]?\nEdit: Finally got it. The rotation must be clockwise as mentioned by some of the users in the replies. It was my mistake I didn't read the question carefully.Â Read more327cache_2110 hours agoBased on the second part of that first image, I'm guessing this is a question you can expect to get from Telsa or XÂ Read more412sixplosive9 hours agoheil leetcode!!Â Read more17Aashutosh SinghFeb 16, 2025I can't believe i was able to solve it, such a Good morning it is. IMO Q3 was difficult than Q4Â Read more175Vitaliy Cherkasskiy6 hours ago\nSees the first picture\nsighs\nGoes into the comment section\nÂ Read more14Viktor KustovFeb 17, 2025I'm the only one, who missed that the next step after 1 must be exactly 2, not 0 or 2? It cost me 2 hours of useless debugging... ))Â Read moreTip113123414Copyright Â© 2025 LeetCode. All rights reserved.",
        "notes": "Length of Longest V-Shaped Diagonal Segment\n\n          - Summary: The code uses a 3D array `memo` for dynamic programming to store results of subproblems, a 2D array `grid` representing the input matrix, and an array `DIRS` to define diagonal directions.  It iterates through the grid, and for each cell with value 1, performs a depth-first search (`dfs`) to find the longest V-shaped diagonal segment starting from that cell. The `dfs` function explores different diagonal directions and turns, using memoization to avoid redundant computations. The algorithm returns the length of the longest V-shaped segment found.\n\n          - Time Complexity: O(mn*4^L), where m and n are the dimensions of the grid and L is the maximum length of a V-shaped diagonal segment. The time complexity is dominated by the `dfs` function, which explores at most 4 branches at each step in the worst-case.  The memoization helps to reduce the number of recursive calls.\n          - Space Complexity: O(mn*8), dominated by the 3D memoization array `memo`. The array has dimensions m x n x 8, where 8 represents the number of possible states for `mask` (4 directions x 2 turn states)."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-27T11:59:12.994Z"
    }
  ]
}