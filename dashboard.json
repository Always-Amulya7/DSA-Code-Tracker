{
  "metadata": {
    "totalProblems": 8,
    "lastUpdated": "2025-08-28T12:18:25.757Z",
    "breakdown": {
      "Codechef": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 7,
        "Easy": 2,
        "Medium": 3,
        "Hard": 2
      },
      "Hackerrank": {
        "total": 1,
        "Easy": 0,
        "Medium": 1,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "hackerrank-medium-java-static-initializer-block",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Java Static Initializer Block",
      "language": "java",
      "files": {
        "code": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n    static int B;\n    static int H;\n    static boolean flag;\n\n    static {\n        Scanner sc = new Scanner(System.in);\n        B = sc.nextInt();\n        H = sc.nextInt();\n\n        try {\n            if (B <= 0 || H <= 0) {\n                throw new Exception(\"Breadth and height must be positive\");\n            } else {\n                flag = true;\n            }\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    public static void main(String[] args) {\n        if (flag) {\n            int area = B * H;\n            System.out.println(area);\n        }\n    }\n}",
        "readme": "null\n\nStatic initialization blocks are executed when the class is loaded, and you can initialize static variables in those blocks.\n\nIt's time to test your knowledge of Static initialization blocks. You can read about it here.\n\nYou are given a class Solution with a main method. Complete the given code so that it outputs the area of a parallelogram with breadth  and height . You should read the variables from the standard input.\n\nIf  or  , the output should be \"java.lang.Exception: Breadth and height must be positive\" without quotes.\n\nInput Format\n\nThere are two lines of input. The first line contains : the breadth of the parallelogram. The next line contains : the height of the parallelogram.\n\nConstraints\n\nOutput Format\n\nIf both values are greater than zero, then the main method must output the area of the parallelogram. Otherwise, print \"java.lang.Exception: Breadth and height must be positive\" without quotes.\n\nSample input 1\n\n1\n3\n\n\nSample output 1\n\n3\n\n\nSample input 2\n\n-1\n2\n\n\nSample output 2\n\njava.lang.Exception: Breadth and height must be positive",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-28T12:18:25.645Z"
    },
    {
      "id": "leetcode-easy-maximum-area-of-longest-diagonal-rectangle",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Maximum Area of Longest Diagonal Rectangle",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int areaOfMaxDiagonal(int[][] dimensions) {\n        int n = dimensions.length;\n        int maxArea = 0, maxDiag = 0;\n\n        for (int i = 0; i < n; i++) {\n            int l = dimensions[i][0];\n            int w = dimensions[i][1];\n            int currDiag = l * l + w * w;\n\n            if (currDiag > maxDiag || (currDiag == maxDiag && l * w > maxArea)) {\n                maxDiag = currDiag;\n                maxArea = l * w;\n            }\n        }\n        return maxArea;\n    }\n}",
        "readme": "3000. Maximum Area of Longest Diagonal RectangleEasyTopicsCompaniesHintYou are given a 2D 0-indexed integer array dimensions.\n\nFor all indices i, 0 <= i < dimensions.length, dimensions[i][0] represents the length and dimensions[i][1] represents the width of the rectangle i.\n\nReturn the area of the rectangle having the longest diagonal. If there are multiple rectangles with the longest diagonal, return the area of the rectangle having the maximum area.\n\n \nExample 1:\n\nInput: dimensions = [[9,3],[8,6]]\nOutput: 48\nExplanation: \nFor index = 0, length = 9 and width = 3. Diagonal length = sqrt(9 * 9 + 3 * 3) = sqrt(90) ≈ 9.487.\nFor index = 1, length = 8 and width = 6. Diagonal length = sqrt(8 * 8 + 6 * 6) = sqrt(100) = 10.\nSo, the rectangle at index 1 has a greater diagonal length therefore we return area = 8 * 6 = 48.\n\n\nExample 2:\n\nInput: dimensions = [[3,4],[4,3]]\nOutput: 12\nExplanation: Length of diagonal is the same for both which is 5, so maximum area = 12.\n\n\n \nConstraints:\n\n\n\t1 <= dimensions.length <= 100\n\tdimensions[i].length == 2\n\t1 <= dimensions[i][0], dimensions[i][1] <= 100\n\n Seen this question in a real interview before?1/5YesNoAccepted166,224/363.6KAcceptance Rate45.7%TopicsArrayWeekly Contest 379CompaniesHint 1Diagonal of rectangle is sqrt(length2 + width2).Discussion (129)Choose a typeComment💡 Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestJedmengAug 26, 2025This is my 1000th POTD 😝\n Read more29116DamonJul 10, 2025Optimisation tip:\nDon't need to calculate the root\nsqrt(x^2+y^2) can just become x^2 + y^2\nsqrt is quite demanding for performance, so this can be a good optimisation Read moreTip11910NerverAug 26, 2025Acceptance rate is low because people (including myself) can't read 🤡 Read more1145SmarikaJan 11, 2024Try this test case b4 submitting\nGood day :))\ndimensions =\n[[4,7],[8,9],[5,3],[6,10],[2,9],[3,10],[2,2],[5,8],[5,10],[5,6],[8,9],[10,7],[8,9],[3,7],[2,6],[5,1],[7,4],[1,10],[1,7],[6,9],[3,3],[4,6],[8,2],[10,6],[7,9],[9,2],[1,2],[3,8],[10,2],[4,1],[9,7],[10,3],[6,9],[9,8],[7,7],[5,7],[5,4],[6,5],[1,8],[2,3],[7,10],[3,9],[5,7],[2,4],[5,6],[9,5],[8,8],[8,10],[6,8],[5,1],[10,8],[7,4],[2,1],[2,7],[10,3],[2,5],[7,6],[10,5],[10,9],[5,7],[10,6],[4,3],[10,4],[1,5],[8,9],[3,1],[2,5],[9,10],[6,6],[5,10],[10,2],[6,10],[1,1],[8,6],[1,7],[6,3],[9,3],[1,4],[1,1],[10,4],[7,9],[4,5],[2,8],[7,9],[7,3],[4,9],[2,8],[4,6],[9,1],[8,4],[2,4],[7,8],[3,5],[7,6],[8,6],[4,7],[25,60],[39,52],[16,63],[33,56]] Read more393Sam_ORAug 26, 20252012 type interview question: Read moreFeedback361Shivam KumarSep 13, 2024I can't understand why has this problem such a low acceptance rate !? It isn't even a lil bit tough..! Read more246Anish SachdevaJul 07, 2024The problem description needs to be fixed !! it says:\nIf there are multiple rectangles with the longest diagonal, return the area of the rectangle having the maximum area.\ni would assume having the maximum area means maximum among all rectangles, but apparently this means maximum among rectangles with same max diagonal length. This is hyper slippery ground !!! and needs to be fixed asap. Cost me a good 30 mins. Read more557Hritam ChowdhuryJan 07, 2024one test case is failing\n[[4,7],[8,9],[5,3],[6,10],[2,9],[3,10],[2,2],[5,8],[5,10],[5,6],[8,9],[10,7],[8,9],[3,7],[2,6],[5,1],[7,4],[1,10],[1,7],[6,9],[3,3],[4,6],[8,2],[10,6],[7,9],[9,2],[1,2],[3,8],[10,2],[4,1],[9,7],[10,3],[6,9],[9,8],[7,7],[5,7],[5,4],[6,5],[1,8],[2,3],[7,10],[3,9],[5,7],[2,4],[5,6],[9,5],[8,8],[8,10],[6,8],[5,1],[10,8],[7,4],[2,1],[2,7],[10,3],[2,5],[7,6],[10,5],[10,9],[5,7],[10,6],[4,3],[10,4],[1,5],[8,9],[3,1],[2,5],[9,10],[6,6],[5,10],[10,2],[6,10],[1,1],[8,6],[1,7],[6,3],[9,3],[1,4],[1,1],[10,4],[7,9],[4,5],[2,8],[7,9],[7,3],[4,9],[2,8],[4,6],[9,1],[8,4],[2,4],[7,8],[3,5],[7,6],[8,6],[4,7],[25,60],[39,52],[16,63],[33,56]]\nwhat is the problem in the solution:\nclass Solution {\npublic:\nint areaOfMaxDiagonal(vector<vector>& dimensions) {\n    int maxArea=0;\n    double maxD = 0;\n    int n = dimensions.size();\n    int l,b;\n    double d;\n    \n    for(int i=0;i<n;i++) {\n        \n         l = dimensions[i][0];\n         b = dimensions[i][1];\n         d = sqrt(l*l + b*b);\n        // cout<<d<<\",\";\n        if(d>=maxD) {\n            maxArea = l*b;\n            maxD=d;\n        } \n    }\n    \n    return maxArea;\n    \n}\n}; Read more175Yuyi_HaoJan 09, 2024good question to test conditional logic Read more151Azhar Uddin SheikhJan 09, 2024some test cases\n[[4,10],[4,9],[9,3],[10,8]]\n[[2,6],[5,1],[3,10],[8,4]]\n[[25,60], [39,52], [33,56], [16,63]]\n[[6,5],[8,6],[2,10],[8,1],[9,2],[3,5],[3,5]] Read more14123413Copyright © 2025 LeetCode. All rights reserved.",
        "notes": "Maximum Area of Longest Diagonal Rectangle\n\n          - Summary: The code uses a 2D integer array to represent the dimensions of rectangles. It iterates through each rectangle, calculating the square of its diagonal using the Pythagorean theorem.  It then updates the maximum diagonal and corresponding area if a larger diagonal is found or if the diagonals are equal but the area is larger. Finally, it returns the maximum area found.\n\n          - Time Complexity: O(n), where n is the number of rectangles. This is because the code iterates through the input array once.\n          - Space Complexity: O(1). The algorithm uses a constant amount of extra space to store variables like maxArea and maxDiag, regardless of the input size."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-28T12:18:25.636Z"
    },
    {
      "id": "leetcode-easy-roman-to-integer",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Roman to Integer",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int romanToInt(String s) {\n        int Number = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (i < s.length() - 1) {\n                if (getValue(s.charAt(i)) < getValue(s.charAt(i + 1))) {\n                    Number -= getValue(s.charAt(i));\n                    continue;\n                }\n            }\n            Number += getValue(s.charAt(i));\n        }\n        return Number;\n    }\n    \n    private int getValue(char c) {\n        if (c == 'I') return 1;\n        else if (c == 'V') return 5;\n        else if (c == 'X') return 10;\n        else if (c == 'L') return 50;\n        else if (c == 'C') return 100;\n        else if (c == 'D') return 500;\n        else return 1000;\n    }\n}",
        "readme": "13. Roman to IntegerSolvedEasyTopicsCompaniesHintRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\n\n\tI can be placed before V (5) and X (10) to make 4 and 9. \n\tX can be placed before L (50) and C (100) to make 40 and 90. \n\tC can be placed before D (500) and M (1000) to make 400 and 900.\n\n\nGiven a roman numeral, convert it to an integer.\n\n \nExample 1:\n\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\n\n\nExample 2:\n\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n\n\nExample 3:\n\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 15\n\ts contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\n\tIt is guaranteed that s is a valid roman numeral in the range [1, 3999].\n\n Seen this question in a real interview before?1/5YesNoAccepted5,122,259/7.8MAcceptance Rate65.3%TopicsHash TableMathStringCompaniesHint 1Problem is simpler to solve by working the string from back to front and using a map.Similar QuestionsInteger to RomanMediumDiscussion (510)Choose a typeComment💡 Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestalienfuyuDec 09, 2022I find a little bit nonsense to try to use the less memory and CPU possible. A good solution is not the most efficient one but a balance between clean code / readability and performance. Being a one liner is not to be smart, it's having a ego two mountains tall. Let's not forget we code for others. Read more81318samikshagodghate22Apr 23, 2024who tf said its easy Read more73819KhaledLeetFeb 01, 2023My first problem on leetcode :) Read more69926Numaira NawazJun 22, 2023My third problem on leetcode :)\nbut it doesn't look easy :( Read more40820HappyJun 12, 2016I dont quite understand why the frequency of this problem appeared in real interview is so high.\nWhat this problem test us?\nI don't think anyone familiar with the law of roman numbers. Read more26813Derek PapierskiDec 17, 2022as a beginner, here are some python hints that might help other newbies start off in the right direction:\n\nuse a dictionary for the roman numeral values\nuse enumerate when iterating through the input string (i always forget to use this)\nto distinguish \"VI\"=6, but \"IV\"=4, you need to see if the numeric value of the next character is greater than the numeric value of the current character\n Read moreTip3378AlgoEngineApr 28, 2023Video that visualizes two different solutions:\n Read moreTip1075kaiyu-CNAug 14, 2024This is my first algorithm question . I have spent two weeks to solve it . Although the time I spent is so long but when I accomplish it completely , I feel satisfied and delighted . I am writing these words in the hope of keeping a memory. I know that Leetcode has many excellent programmer predecessor, and I want to learn from them. I hope that in the future, I can solve algorithm problems faster and faster, and I also hope that my future self can thank the hardworking self now. Keep up the good work! Read more1017JackyMay 04, 2020The roman numeral for 49 is \"XLIX\".\nReference:\n\nhttps://roman-numerals.info/49\nhttps://www.rapidtables.com/math/symbols/roman-numerals-1-100.html\nhttps://www.calculateme.com/roman-numerals/to-roman/49\n\nHOWEVER, LeetCode's answer is IL which is wrong according to references cited above. It is also wrong according to their own problem descritpion wherein thay stated:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\n\nGranted, the above description is vague enought that it does not explicity state that \"I\" cannot be placed before \"L\" or \"C\" but I think it can be assumed. Read more726iL YDOCSep 12, 2020Tried \"IM\" which is not a valid Roman numeral in the testcase console, and it says Expected: 999\nShouldn't such case return None or -1 to indicate invalid input? Read more4213123451Copyright © 2025 LeetCode. All rights reserved.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-28T12:18:25.636Z"
    },
    {
      "id": "leetcode-medium-longest-palindromic-substring",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Longest Palindromic Substring",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() == 0) {\n            return \"\";\n        }\n\n        int start = 0;\n        int end = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            int odd = expandAroundCenter(s, i, i);\n            int even = expandAroundCenter(s, i, i + 1);\n            int max_len = Math.max(odd, even);\n\n            if (max_len > end - start) {\n                start = i - (max_len - 1) / 2;\n                end = i + max_len / 2;\n            }\n        }\n\n        return s.substring(start, end + 1);        \n    }\n\n    private int expandAroundCenter(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }    \n}",
        "readme": "5. Longest Palindromic SubstringSolvedMediumTopicsCompaniesHintGiven a string s, return the longest palindromic substring in s.\n\n \nExample 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\n\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 1000\n\ts consist of only digits and English letters.\n\n Seen this question in a real interview before?1/5YesNoAccepted4,094,396/11.3MAcceptance Rate36.3%TopicsTwo PointersStringDynamic ProgrammingCompaniesHint 1How can we reuse a previously computed palindrome to compute a larger palindrome?Hint 2If “aba” is a palindrome, is “xabax” a palindrome? Similarly is “xabay” a palindrome?Hint 3Complexity based hint:\nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation.Similar QuestionsShortest PalindromeHardPalindrome PermutationEasyPalindrome PairsHardLongest Palindromic SubsequenceMediumPalindromic SubstringsMediumMaximum Number of Non-overlapping Palindrome SubstringsHardDiscussion (496)Choose a typeComment💡 Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestZenMasterVNov 05, 2022Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills\n\" Please don't post any solutions in this discussion tab\"\nIt's almost the rule to find the exact opposite for the discussion of every question. I don't want to see your damned solution! Read more1.3K13Akhil ChauhanOct 27, 2023More like longest palindromic nightmare Read more2191SwetNov 04, 2022It took me an hour to solve this even though it's not that difficult but anyhow came to the conclusion that I need to do more practice. Read more1273sanemdeepakJan 16, 2019For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string? Read more17720Neetika BansalJun 04, 2014From the leetcode blog, one of the methods of solving this is:\nA common mistake:\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\nReverse S and become S’. Find the longest common substring between S and S’, which must also be the longest palindromic substring.\nThis seemed to work, let’s see some examples below.\nFor example,\nS = “caba”, S’ = “abac”.\nThe longest common substring between S and S’ is “aba”, which is the answer.\nLet’s try another example:\nS = “abacdfgdcaba”, S’ = “abacdgfdcaba”.\nThe longest common substring between S and S’ is “abacd”. Clearly, this is not a valid palindrome.\nWe could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring’s indices are the same as the reversed substring’s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.\nIs this part correct?\nexample string: abcxycba\nreverse string:  abcxycba\nThe substring indices are same as reversed string original indices and yet it is not a palindrome? Read more949napoleonNov 08, 2013My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster? Read more10313Tomas SandvenApr 25, 2023I'm getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\ns =\nDid I break it? Read moreFeedback47884danieNov 14, 2016I submitted my solution, and received a Time Limit Exceeded on this test case:\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\n\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug?\n Read more4410miklerAug 25, 2017So I think I finally understood logic of test creators.\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG.\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\nif s == s[::-1]: return s Read more254AlgoEngineJun 17, 2023Visualization of \"Expand from Centers\" solution:\n Read more231123450Copyright © 2025 LeetCode. All rights reserved.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-28T12:18:25.638Z"
    },
    {
      "id": "leetcode-medium-sort-matrix-by-diagonals",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Sort Matrix by Diagonals",
      "language": "java",
      "files": {
        "code": "import java.util.*;\n\nclass Solution {\n    public int[][] sortMatrix(int[][] matrix) {\n        Map<Integer, PriorityQueue<Integer>> diagonalMap = new HashMap<>();\n        int rows = matrix.length, cols = matrix[0].length;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                int key = i - j;\n                diagonalMap.putIfAbsent(key, key < 0 ? new PriorityQueue<>() \n                                                     : new PriorityQueue<>(Collections.reverseOrder()));\n                diagonalMap.get(key).offer(matrix[i][j]);\n            }\n        }\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                int key = i - j;\n                matrix[i][j] = diagonalMap.get(key).poll();\n            }\n        }\n\n        return matrix;\n    }\n}",
        "readme": "DailyCodingChallengeCompleted!,CompletionStreak:,43,Days,Consistencyiskey,seeyoutomorrow!\n\nYou are given an n x n square matrix of integers grid. Return the matrix such that:\n\n\n\tThe diagonals in the bottom-left triangle (including the middle diagonal) are sorted in non-increasing order.\n\tThe diagonals in the top-right triangle are sorted in non-decreasing order.\n\n\n \nExample 1:\n\n\nInput: grid = [[1,7,3],[9,8,2],[4,5,6]]\n\nOutput: [[8,2,3],[9,6,7],[4,5,1]]\n\nExplanation:\n\n\n\nThe diagonals with a black arrow (bottom-left triangle) should be sorted in non-increasing order:\n\n\n\t[1, 8, 6] becomes [8, 6, 1].\n\t[9, 5] and [4] remain unchanged.\n\n\nThe diagonals with a blue arrow (top-right triangle) should be sorted in non-decreasing order:\n\n\n\t[7, 2] becomes [2, 7].\n\t[3] remains unchanged.\n\n\n\nExample 2:\n\n\nInput: grid = [[0,1],[1,2]]\n\nOutput: [[2,1],[1,0]]\n\nExplanation:\n\n\n\nThe diagonals with a black arrow must be non-increasing, so [0, 2] is changed to [2, 0]. The other diagonals are already in the correct order.\n\n\nExample 3:\n\n\nInput: grid = [[1]]\n\nOutput: [[1]]\n\nExplanation:\n\nDiagonals with exactly one element are already in order, so no changes are needed.\n\n\n \nConstraints:\n\n\n\tgrid.length == grid[i].length == n\n\t1 <= n <= 10\n\t-105 <= grid[i][j] <= 105",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-28T12:18:25.640Z"
    },
    {
      "id": "leetcode-medium-zigzag-conversion",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Zigzag Conversion",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public String convert(String s, int numRows) {\n       if (numRows == 1 || numRows >= s.length()) {\n            return s;\n        }\n\n        int idx = 0, d = 1;\n        List<Character>[] rows = new ArrayList[numRows];\n        for (int i = 0; i < numRows; i++) {\n            rows[i] = new ArrayList<>();\n        }\n\n        for (char c : s.toCharArray()) {\n            rows[idx].add(c);\n            if (idx == 0) {\n                d = 1;\n            } else if (idx == numRows - 1) {\n                d = -1;\n            }\n            idx += d;\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (List<Character> row : rows) {\n            for (char c : row) {\n                result.append(c);\n            }\n        }\n\n        return result.toString();        \n    }\n}",
        "readme": "6. Zigzag ConversionMediumTopicsCompaniesThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numRows);\n\n\n \nExample 1:\n\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n\n\nExample 2:\n\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\n\nExample 3:\n\nInput: s = \"A\", numRows = 1\nOutput: \"A\"\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 1000\n\ts consists of English letters (lower-case and upper-case), ',' and '.'.\n\t1 <= numRows <= 1000\n\n Seen this question in a real interview before?1/5YesNoAccepted1,877,220/3.6MAcceptance Rate52.2%TopicsStringCompaniesDiscussion (461)Choose a typeComment💡 Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestwaitingtodieOct 26, 2017No details of what is required at all - it's almost like this:\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question. Read more2.6K35Manish SutharFeb 03, 2023Ironically, Paypal is laying off Read more1.2K8Bashishtha KannaujiyaFeb 03, 2023I am ignoring this question for a long time. Read more4836jc334259684Feb 03, 2023Don't think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best Read moreTip21316Mark WatsonJun 13, 2024Note: the zig-zag pattern is like this y'all\n|    /|    /|    /|\n|  /  |  /  |  /  |\n|/    |/    |/    | Read more1777milk1_0Feb 03, 2023Alien problem again today haha Read more1761Sergei PlaxienkoFeb 03, 2023The description better be changed to reflex the reality to \"PAYPALISFIRING\". Read moreFeedback1721VgnApr 21, 2015Dear LeetCode,\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\nThanks. Read more1906LeetcodeProtectorFeb 03, 2023\n\nThings changed pretty quickly. Read more461vigneshmFeb 05, 2014I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ Read more45123447Copyright © 2025 LeetCode. All rights reserved.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-08-28T12:18:25.640Z"
    },
    {
      "id": "leetcode-hard-length-of-longest-v-shaped-diagonal-segment",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Length of Longest V-Shaped Diagonal Segment",
      "language": "java",
      "files": {
        "code": "/**\nTime Complexity: O(mn)\nSpace Complexity: O(mn)\n */\nclass Solution {\n    private static final int[][] DIRS = { { 1, 1 }, { 1, -1 }, { -1, -1 }, { -1, 1 } };\n\n    public int lenOfVDiagonal(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        // Too many dimensions affect efficiency, so compress k and canTurn into one int\n        int[][][] memo = new int[m][n][1 << 3];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] != 1) {\n                    continue;\n                }\n                int[] maxs = { m - i, j + 1, i + 1, n - j }; //Theoretical maximum (go to the boundary)\n                for (int k = 0; k < 4; k++) { // Enumerate starting direction\n                    // Optimization 1: If the theoretical maximum does not exceed ans, skip recursion\n                    if (maxs[k] > ans) { \n                        ans = Math.max(ans, dfs(i, j, k, 1, 2, grid, memo) + 1);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n\n    private int dfs(int i, int j, int k, int canTurn, int target, int[][] grid, int[][][] memo) {\n        i += DIRS[k][0];\n        j += DIRS[k][1];\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] != target) {\n            return 0;\n        }\n        int mask = k << 1 | canTurn;\n        if (memo[i][j][mask] > 0) {\n            return memo[i][j][mask];\n        }\n        int res = dfs(i, j, k, canTurn, 2 - target, grid, memo);\n        if (canTurn == 1) {\n            int[] maxs = { grid.length - i - 1, j, i, grid[i].length - j - 1 }; // Theoretical maximum (go to the boundary)\n            k = (k + 1) % 4;\n            // Optimization 2: If the theoretical maximum does not exceed res, skip recursion\n            if (maxs[k] > res) {\n                res = Math.max(res, dfs(i, j, k, 0, 2 - target, grid, memo));\n            }\n        }\n        return memo[i][j][mask] = res + 1;\n    }\n}",
        "readme": "3459. Length of Longest V-Shaped Diagonal SegmentSolvedHardTopicsCompaniesHintYou are given a 2D integer matrix grid of size n x m, where each element is either 0, 1, or 2.\n\nA V-shaped diagonal segment is defined as:\n\n\n\tThe segment starts with 1.\n\tThe subsequent elements follow this infinite sequence: 2, 0, 2, 0, ....\n\tThe segment:\n\t\n\t\tStarts along a diagonal direction (top-left to bottom-right, bottom-right to top-left, top-right to bottom-left, or bottom-left to top-right).\n\t\tContinues the sequence in the same diagonal direction.\n\t\tMakes at most one clockwise 90-degree turn to another diagonal direction while maintaining the sequence.\n\t\n\t\n\n\n\n\nReturn the length of the longest V-shaped diagonal segment. If no valid segment exists, return 0.\n\n \nExample 1:\n\n\nInput: grid = [[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]\n\nOutput: 5\n\nExplanation:\n\n\n\nThe longest V-shaped diagonal segment has a length of 5 and follows these coordinates: (0,2) → (1,3) → (2,4), takes a 90-degree clockwise turn at (2,4), and continues as (3,3) → (4,2).\n\n\nExample 2:\n\n\nInput: grid = [[2,2,2,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]\n\nOutput: 4\n\nExplanation:\n\n\n\nThe longest V-shaped diagonal segment has a length of 4 and follows these coordinates: (2,3) → (3,2), takes a 90-degree clockwise turn at (3,2), and continues as (2,1) → (1,0).\n\n\nExample 3:\n\n\nInput: grid = [[1,2,2,2,2],[2,2,2,2,0],[2,0,0,0,0],[0,0,2,2,2],[2,0,0,2,0]]\n\nOutput: 5\n\nExplanation:\n\n\n\nThe longest V-shaped diagonal segment has a length of 5 and follows these coordinates: (0,0) → (1,1) → (2,2) → (3,3) → (4,4).\n\n\nExample 4:\n\n\nInput: grid = [[1]]\n\nOutput: 1\n\nExplanation:\n\nThe longest V-shaped diagonal segment has a length of 1 and follows these coordinates: (0,0).\n\n\n \nConstraints:\n\n\n\tn == grid.length\n\tm == grid[i].length\n\t1 <= n, m <= 500\n\tgrid[i][j] is either 0, 1 or 2.\n\n Seen this question in a real interview before?1/5YesNoAccepted27,365/53.5KAcceptance Rate51.2%TopicsArrayDynamic ProgrammingMemoizationMatrixWeekly Contest 437CompaniesHint 1Use dynamic programming to determine the best point to make a 90-degree rotation in the diagonal path while maintaining the required sequence.Hint 2Represent dynamic programming states as (row, col, currentDirection, hasMadeTurnYet). Track the current position, direction of traversal, and whether a turn has already been made, and take transitions accordingly to find the longest V-shaped diagonal segment.Discussion (138)Choose a typeComment💡 Discussion Rules1. Please don't post any solutions in this discussion.2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there.Sort by:BestGaurav KumarJun 09, 2025Kanye would love the first picture :) Read more175Amr Samy10 hours agoMy 3-day streak ends here. Read more1469Aradhya Verma10 hours agoI think i should work at Burger king Read more905parthasarathireddy10 hours agoToday is Vinayaka Chaturthi. LeetCode decided not to let us celebrate by giving a hard problem. Anyway, wishing you all a Happy Vinayaka Chavithi! Read more2248amcodes2k2Feb 16, 2025Can someone explain to me how the answer to the testcase [[1,1,1,2,0,0],[0,0,0,0,1,2]] is 2? Shouldn't it be 3 [(1, 4) -> (0, 3) -> (1,2)]?\nEdit: Finally got it. The rotation must be clockwise as mentioned by some of the users in the replies. It was my mistake I didn't read the question carefully. Read more327cache_2110 hours agoBased on the second part of that first image, I'm guessing this is a question you can expect to get from Telsa or X Read more412sixplosive9 hours agoheil leetcode!! Read more17Aashutosh SinghFeb 16, 2025I can't believe i was able to solve it, such a Good morning it is. IMO Q3 was difficult than Q4 Read more175Vitaliy Cherkasskiy6 hours ago\nSees the first picture\nsighs\nGoes into the comment section\n Read more14Viktor KustovFeb 17, 2025I'm the only one, who missed that the next step after 1 must be exactly 2, not 0 or 2? It cost me 2 hours of useless debugging... )) Read moreTip113123414Copyright © 2025 LeetCode. All rights reserved.",
        "notes": "Length of Longest V-Shaped Diagonal Segment\n\n          - Summary: The code uses a 3D array `memo` for dynamic programming to store results of subproblems, a 2D array `grid` representing the input matrix, and an array `DIRS` to define diagonal directions.  It iterates through the grid, and for each cell with value 1, performs a depth-first search (`dfs`) to find the longest V-shaped diagonal segment starting from that cell. The `dfs` function explores different diagonal directions and turns, using memoization to avoid redundant computations. The algorithm returns the length of the longest V-shaped segment found.\n\n          - Time Complexity: O(mn*4^L), where m and n are the dimensions of the grid and L is the maximum length of a V-shaped diagonal segment. The time complexity is dominated by the `dfs` function, which explores at most 4 branches at each step in the worst-case.  The memoization helps to reduce the number of recursive calls.\n          - Space Complexity: O(mn*8), dominated by the 3D memoization array `memo`. The array has dimensions m x n x 8, where 8 represents the number of possible states for `mask` (4 directions x 2 turn states)."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-28T12:18:25.642Z"
    },
    {
      "id": "leetcode-hard-regular-expression-matching",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Regular Expression Matching",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        int m = s.length(), n = p.length();\n        boolean[][] dp = new boolean[m + 1][n + 1];\n        dp[0][0] = true;\n        for (int j = 2; j <= n; j++) {\n            if (p.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 2];\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p.charAt(j - 1) == '*') {\n                    dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));\n                } else {\n                    dp[i][j] = dp[i - 1][j - 1] && (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.');\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}",
        "readme": "StringDynamicProgrammingRecursion\n\nGiven an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n\n\t'.' Matches any single character.​​​​\n\t'*' Matches zero or more of the preceding element.\n\n\nThe matching should cover the entire input string (not partial).\n\n \nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n\nExample 3:\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 20\n\t1 <= p.length <= 20\n\ts contains only lowercase English letters.\n\tp contains only lowercase English letters, '.', and '*'.\n\tIt is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
        "notes": "Regular Expression Matching\n\n          - Summary: This Java code implements a dynamic programming solution to the regular expression matching problem. It uses a 2D boolean array (dp) to store whether a substring of s matches a substring of p. The algorithm iteratively builds the dp array, considering cases where the pattern character is '*' (representing zero or more occurrences) or a regular character.  The final result, indicating whether the entire string s matches the entire pattern p, is stored in dp[m][n], where m and n are the lengths of s and p, respectively.\n\n          - Time Complexity: O(mn), where m is the length of string s and n is the length of pattern p. This is because the nested loops iterate through all possible substring matches.\n          - Space Complexity: O(mn) due to the use of the dp array which has dimensions (m+1) x (n+1) to store boolean values representing matching substrings. The space used is directly proportional to the product of input string and pattern lengths."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-28T12:18:25.643Z"
    }
  ]
}